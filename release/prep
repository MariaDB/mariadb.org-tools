#!/bin/bash
#===============================================================================
#
#          FILE: prep
# 
#         USAGE: ./prep
# 
#   DESCRIPTION: This script exists so that I don't need to remember or look up
#                where things are when it is time to prepare a release. It also
#                ensures no steps are forgotten, and prevents many errors.
# 
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: Daniel Bartholomew (db), dbart@mariadb.org
#  ORGANIZATION: 
#       CREATED: 03/16/2015 20:37
#      REVISION:  ---
#===============================================================================

umask 002

#killall gpg-agent

set -eu
  # -e  Exit immediately if a simple command exits with a non-zero status,
  #     unless the command that fails is part of an until or  while loop, part
  #     of an if statement, part of a && or || list, or if the command's return
  #     status is being inverted using !.  -o errexit
  #
  # -u  Treat unset variables as an error when performing parameter expansion.
  #     An error message will be written to the standard error, and a
  #     non-interactive shell will exit.
  #
  # -x  Print a trace of simple commands and their arguments after they are
  #     expanded and before they are executed.

#-------------------------------------------------------------------------------
# Options below this point you probably don't need to change
#-------------------------------------------------------------------------------

# Various miscellaneous options
rsync_opts="-a -L --info=progress2"

# set location of prep.conf and prep.log to XDG-compatible directories and then
# create them if they don't exist
dir_conf=${XDG_CONFIG_HOME:-~/.config}
dir_log=${XDG_DATA_HOME:-~/.local/share}

if [ ! -d ${dir_conf}/ ];then
  mkdir -vp ${dir_conf}
fi

if [ ! -d ${dir_log}/ ];then
  mkdir -vp ${dir_log}
fi




#-------------------------------------------------------------------------------
#  The ${build_dirs} option contains two-part names of various bintar builds
#  separated by a colon. The first part is the name of the directory that
#  buildbot saves, the second part is the name we use on the mirrors.
#-------------------------------------------------------------------------------
#build_dirs="kvm-bintar-centos5-amd64:bintar-linux-x86_64 kvm-bintar-centos5-x86:bintar-linux-x86 kvm-bintar-hardy-amd64:bintar-linux-hardy-x86_64 kvm-bintar-hardy-x86:bintar-linux-hardy-x86 kvm-bintar-quantal-amd64:bintar-linux-glibc_214-x86_64 kvm-bintar-quantal-x86:bintar-linux-glibc_214-x86 kvm-tarbake-jaunty-x86:source sol10-64:bintar-sol10-64 bsd9-64:bintar-bsd9-64 opensolaris-511-bintar:bintar-opensolaris-511"

# Sunanda Menon : 02/27/2015
# Splitting build dirs (refer ME-91). 
# Enterprise builds need to grab only Linux 64bit, no 32bit builds

set_build_dirs_variables() {
  case ${major} in
    10.6|10.7|10.8|10.9)
      build_dirs_x86=""
      build_dirs_x86_64="
        kvm-bintar-centos74-amd64:bintar-linux-systemd-x86_64
        kvm-tarbake-jaunty-x86:source
      "
      ci_build_dirs_x86=""
      ci_build_dirs_x86_64=""
      ci_build_dirs_aarch64=""
      ci_build_dirs_ppc64le=""
      ;;
    10.5)
      build_dirs_x86="
        kvm-bintar-centos6-x86:bintar-linux-x86
        kvm-bintar-trusty-x86:bintar-linux-systemd-x86
        "
      build_dirs_x86_64="
        kvm-bintar-centos6-amd64:bintar-linux-x86_64
        kvm-bintar-trusty-amd64:bintar-linux-systemd-x86_64
        kvm-tarbake-jaunty-x86:source
        mac-1012-pkg:macOS
        "
      ci_build_dirs_x86="
        32bit-debian-9:bintar-debian-9-x86
        32bit-debian-sid:bintar-debian-sid-x86
        32bit-ubuntu-1604:bintar-ubuntu-1604-x86
        "
      ci_build_dirs_x86_64="
        amd64-centos-7:bintar-centos-7-amd64
        amd64-centos-8:bintar-centos-8-amd64
        amd64-debian-10:bintar-debian-10-amd64
        amd64-debian-9:bintar-debian-9-amd64
        amd64-debian-sid:bintar-debian-sid-amd64
        amd64-fedora-32:bintar-fedora-32-amd64
        amd64-fedora-33:bintar-fedora-33-amd64
        amd64-opensuse-15:bintar-opensuse-15-amd64
        amd64-opensuse-42:bintar-opensuse-42-amd64
        amd64-rhel-8:bintar-rhel-8-amd64
        amd64-sles-12:bintar-sles-12-amd64
        amd64-sles-15:bintar-sles-15-amd64
        amd64-ubuntu-1604:bintar-ubuntu-1604-amd64
        amd64-ubuntu-1804:bintar-ubuntu-1804-amd64
        amd64-ubuntu-1804-clang10:bintar-ubuntu-1804-amd64-clang10
        amd64-ubuntu-1804-clang6:bintar-ubuntu-1804-amd64-clang6
        amd64-ubuntu-2004:bintar-ubuntu-2004-amd64
        amd64-ubuntu-2004-clang11:bintar-ubuntu-2004-amd64-clang11
        amd64-ubuntu-2004-gcc10:bintar-ubuntu-2004-amd64-gcc10
        "
      ci_build_dirs_aarch64="
        aarch64-centos-7:bintar-centos-7-aarch64
        aarch64-debian-10:bintar-debian-10-aarch64
        aarch64-debian-9:bintar-debian-9-aarch64
        aarch64-fedora-32:bintar-fedora-32-aarch64
        aarch64-rhel-7:bintar-rhel-7-aarch64
        aarch64-rhel-8:bintar-rhel-8-aarch64
        aarch64-ubuntu-1604:bintar-ubuntu-1604-aarch64
        aarch64-ubuntu-1804:bintar-ubuntu-1804-aarch64
        aarch64-ubuntu-2004:bintar-ubuntu-2004-aarch64
        "
      ci_build_dirs_ppc64le="
        ppc64le-centos-7:bintar-centos-7-ppc64le
        ppc64le-ubuntu-1604:bintar-ubuntu-1604-ppc64le
        ppc64le-ubuntu-1804:bintar-ubuntu-1804-ppc64le
        ppc64le-ubuntu-2004:bintar-ubuntu-2004-ppc64le
        "
      ;;
    10.4|10.3)
      build_dirs_x86="
        kvm-bintar-centos6-x86:bintar-linux-x86
        kvm-bintar-trusty-x86:bintar-linux-systemd-x86
        kvm-bintar-quantal-x86:bintar-linux-glibc_214-x86
        "
      build_dirs_x86_64="
        kvm-bintar-centos6-amd64:bintar-linux-x86_64
        kvm-bintar-trusty-amd64:bintar-linux-systemd-x86_64
        kvm-bintar-quantal-amd64:bintar-linux-glibc_214-x86_64
        kvm-tarbake-jaunty-x86:source
        mac-1012-pkg:macOS
        "
      ci_build_dirs_x86="
        32bit-debian-9:bintar-debian-9-x86
        32bit-debian-sid:bintar-debian-sid-x86
        32bit-ubuntu-1604:bintar-ubuntu-1604-x86
        "
      ci_build_dirs_x86_64="
        centos-7:bintar-centos-7-amd64
        centos-8:bintar-centos-8-amd64
        debian-10:bintar-debian-10-amd64
        debian-9:bintar-debian-9-amd64
        debian-sid:bintar-debian-sid-amd64
        fedora-32:bintar-fedora-32-amd64
        fedora-33:bintar-fedora-33-amd64
        opensuse-15:bintar-opensuse-15-amd64
        opensuse-42:bintar-opensuse-42-amd64
        rhel-8:bintar-rhel-8-amd64
        sles-12:bintar-sles-12-amd64
        sles-15:bintar-sles-15-amd64
        ubuntu-1604:bintar-ubuntu-1604-amd64
        ubuntu-1804:bintar-ubuntu-1804-amd64
        ubuntu-1804-clang10:bintar-ubuntu-1804-amd64-clang10
        ubuntu-1804-clang6:bintar-ubuntu-1804-amd64-clang6
        ubuntu-2004:bintar-ubuntu-2004-amd64
        ubuntu-2004-clang11:bintar-ubuntu-2004-amd64-clang11
        ubuntu-2004-gcc10:bintar-ubuntu-2004-amd64-gcc10
        "
      ci_build_dirs_aarch64="
        aarch64-centos-7:bintar-centos-7-aarch64
        aarch64-debian-10:bintar-debian-10-aarch64
        aarch64-debian-9:bintar-debian-9-aarch64
        aarch64-fedora-32:bintar-fedora-32-aarch64
        aarch64-rhel-7:bintar-rhel-7-aarch64
        aarch64-rhel-8:bintar-rhel-8-aarch64
        aarch64-ubuntu-1604:bintar-ubuntu-1604-aarch64
        aarch64-ubuntu-1804:bintar-ubuntu-1804-aarch64
        aarch64-ubuntu-2004:bintar-ubuntu-2004-aarch64
        "
      ci_build_dirs_ppc64le="
        ppc64le-centos-7:bintar-centos-7-ppc64le
        ppc64le-ubuntu-1604:bintar-ubuntu-1604-ppc64le
        ppc64le-ubuntu-1804:bintar-ubuntu-1804-ppc64le
        ppc64le-ubuntu-2004:bintar-ubuntu-2004-ppc64le
        "
      ;;
    *)
      ci_build_dirs_x86="
        32bit-debian-9:bintar-debian-9-x86
        32bit-debian-sid:bintar-debian-sid-x86
        32bit-ubuntu-1604:bintar-ubuntu-1604-x86
        "
      ci_build_dirs_x86_64="
        amd64-centos-7:bintar-centos-7-amd64
        amd64-centos-8:bintar-centos-8-amd64
        amd64-debian-10:bintar-debian-10-amd64
        amd64-debian-9:bintar-debian-9-amd64
        amd64-debian-sid:bintar-debian-sid-amd64
        amd64-fedora-32:bintar-fedora-32-amd64
        amd64-fedora-33:bintar-fedora-33-amd64
        amd64-opensuse-15:bintar-opensuse-15-amd64
        amd64-opensuse-42:bintar-opensuse-42-amd64
        amd64-rhel-8:bintar-rhel-8-amd64
        amd64-sles-12:bintar-sles-12-amd64
        amd64-sles-15:bintar-sles-15-amd64
        amd64-ubuntu-1604:bintar-ubuntu-1604-amd64
        amd64-ubuntu-1804:bintar-ubuntu-1804-amd64
        amd64-ubuntu-1804-clang10:bintar-ubuntu-1804-amd64-clang10
        amd64-ubuntu-1804-clang6:bintar-ubuntu-1804-amd64-clang6
        amd64-ubuntu-2004:bintar-ubuntu-2004-amd64
        amd64-ubuntu-2004-clang11:bintar-ubuntu-2004-amd64-clang11
        amd64-ubuntu-2004-gcc10:bintar-ubuntu-2004-amd64-gcc10
        "
      ci_build_dirs_aarch64="
        aarch64-centos-7:bintar-centos-7-aarch64
        aarch64-debian-10:bintar-debian-10-aarch64
        aarch64-debian-9:bintar-debian-9-aarch64
        aarch64-fedora-32:bintar-fedora-32-aarch64
        aarch64-rhel-7:bintar-rhel-7-aarch64
        aarch64-rhel-8:bintar-rhel-8-aarch64
        aarch64-ubuntu-1604:bintar-ubuntu-1604-aarch64
        aarch64-ubuntu-1804:bintar-ubuntu-1804-aarch64
        aarch64-ubuntu-2004:bintar-ubuntu-2004-aarch64
        "
      ci_build_dirs_ppc64le="
        ppc64le-centos-7:bintar-centos-7-ppc64le
        ppc64le-ubuntu-1604:bintar-ubuntu-1604-ppc64le
        ppc64le-ubuntu-1804:bintar-ubuntu-1804-ppc64le
        ppc64le-ubuntu-2004:bintar-ubuntu-2004-ppc64le
        "
build_dirs_x86="kvm-bintar-centos5-x86:bintar-linux-x86
                kvm-bintar-quantal-x86:bintar-linux-glibc_214-x86
                kvm-bintar-trusty-x86:bintar-linux-systemd-x86"

build_dirs_x86_64="kvm-bintar-centos5-amd64:bintar-linux-x86_64
                   kvm-bintar-quantal-amd64:bintar-linux-glibc_214-x86_64
                   kvm-bintar-trusty-amd64:bintar-linux-systemd-x86_64
                   kvm-tarbake-jaunty-x86:source
                   sol10-64:bintar-sol10-64
                   mac-1012-pkg:macOS
                   bsd9-64:bintar-bsd9-64
                   opensolaris-511-bintar:bintar-opensolaris-511"
       ;;
  esac
}

#-------------------------------------------------------------------------------
# Dirs for buildbot.mariadb.org
#-------------------------------------------------------------------------------
#ci_dirs_102="aarch64-debian-9-deb-autobake"
#ci_dirs_103="${ci_dirs_102} aarch64-rhel-8-rpm-autobake"
ci_dirs_102="kvm-deb-stretch-aarch64:aarch64-debian-9-deb-autobake kvm-deb-bionic-aarch64:aarch64-ubuntu-1804-deb-autobake kvm-rpm-centos74-aarch64:aarch64-centos-7-rpm-autobake"
ci_dirs_103="${ci_dirs_102} kvm-deb-buster-aarch64:aarch64-debian-10-deb-autobake kvm-deb-focal-aarch64:aarch64-ubuntu-2004-deb-autobake kvm-rpm-rhel8-aarch64:aarch64-rhel-8-rpm-autobake"
ci_dirs_104="${ci_dirs_103}"
ci_dirs_105="${ci_dirs_104} kvm-rpm-fedora34-aarch64:aarch64-fedora-34-rpm-autobake kvm-rpm-fedora35-aarch64:aarch64-fedora-35-rpm-autobake kvm-deb-impish-aarch64:aarch64-ubuntu-2110-deb-autobake kvm-deb-hirsute-aarch64:aarch64-ubuntu-2104-deb-autobake kvm-deb-bullseye-aarch64:aarch64-debian-11-deb-autobake kvm-deb-bullseye-ppc64le:ppc64le-debian-11-deb-autobake kvm-deb-focal-s390x:s390x-ubuntu-2004-deb-autobake kvm-deb-jammy-aarch64:aarch64-ubuntu-2204-deb-autobake"
ci_dirs_106="${ci_dirs_105} kvm-deb-sid-amd64:amd64-debian-sid-deb-autobake kvm-deb-sid-aarch64:aarch64-debian-sid-deb-autobake kvm-deb-sid-ppc64le:ppc64le-debian-sid-deb-autobake"
ci_dirs_107="${ci_dirs_106}"
ci_dirs_108="${ci_dirs_107}"


#-------------------------------------------------------------------------------
# Dirs for buildbot.askmonty.org 
#-------------------------------------------------------------------------------

bb_dirs_102="kvm-deb-bionic-amd64: kvm-deb-bionic-ppc64le: kvm-deb-stretch-amd64: kvm-deb-stretch-ppc64le: kvm-deb-stretch-x86: kvm-rpm-centos73-ppc64: kvm-rpm-centos73-ppc64le: kvm-rpm-centos74-amd64: kvm-zyp-opensuse150-amd64: kvm-zyp-sles125-amd64: kvm-zyp-sles150-amd64:"
bb_dirs_103="${bb_dirs_102} kvm-deb-buster-amd64: kvm-deb-buster-ppc64le: kvm-deb-focal-amd64: kvm-deb-focal-ppc64le: kvm-rpm-rhel8-amd64: kvm-rpm-rhel8-ppc64le:"
bb_dirs_104="${bb_dirs_103}"
bb_dirs_105="${bb_dirs_104} kvm-deb-bullseye-amd64: kvm-deb-impish-amd64: kvm-deb-jammy-amd64: kvm-deb-jammy-ppc64le: kvm-rpm-fedora34-amd64: kvm-rpm-fedora35-amd64:"
bb_dirs_106="${bb_dirs_105}"
bb_dirs_107="${bb_dirs_106}"
bb_dirs_108="${bb_dirs_107}"

full_dirs_102="${bb_dirs_102} ${ci_dirs_102}"
full_dirs_103="${bb_dirs_103} ${ci_dirs_103}"
full_dirs_104="${bb_dirs_104} ${ci_dirs_104}"
full_dirs_105="${bb_dirs_105} ${ci_dirs_105}"
full_dirs_106="${bb_dirs_106} ${ci_dirs_106}"
full_dirs_107="${bb_dirs_107} ${ci_dirs_107}"
full_dirs_108="${bb_dirs_108} ${ci_dirs_108}"


## Enterprise builds should not build solaris10 for now
ent_build_dirs_x86_64="kvm-bintar-centos5-amd64:bintar-linux-x86_64
                       kvm-bintar-quantal-amd64:bintar-linux-glibc_214-x86_64
                       kvm-tarbake-jaunty-x86:source
                       bsd9-64:bintar-bsd9-64
                       opensolaris-511-bintar:bintar-opensolaris-511"

p8_build_dirs="p8-rhel6-bintar:bintar-linux-rhel6-ppc64
               p8-rhel7-bintar:bintar-linux-rhel7-ppc64
               p8-rhel71-bintar:bintar-linux-rhel71-ppc64le
               p8-trusty-bintar:bintar-linux-trusty-ppc64le
               p8-xenial-bintar:bintar-linux-xenial-ppc64le"

# defaults (to prevent errors)
    displayusage="no"
log_displayusage=""
            demo="no"
        log_demo=""
      run_script="no"
  log_run_script=""
          is_ent="no"
      log_is_ent=""
   create_bintar="no"
create_p8_bintar="no"
      create_win="no"
   create_debian="no"
   create_ubuntu="no"
rsync_debian_repo="no"
rsync_ubuntu_repo="no"
      create_yum="no"
     perms_fixed="no"
     incl_galera="no"
      is_cluster="no"
  log_is_cluster=""
             log="no"
          skipit="no"
         log_log=""
   galera_suffix=""
 exclude_release=""
     remote_prep="no"
    skip_staging="yes"
        treeflag=false
         revflag=false
         numflag=false
         tarflag=false
    prev_release=""
      win_remote=false
      ci_release=false

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

runCommand() {
  echo "+ ${@}"
  sleep 1
  if ${@} ; then
    return 0
  else
    return 1
  fi
}

userResponse() {
  question="${@}"
  read -p "${question} " -n 1
  echo
  ANSWER=${REPLY}
  RESPONSE=${REPLY}
  return 0
}

userInput() {
  question="$@"
  echo
  read -p "${question} "
  echo
  INPUT=${REPLY}
  return 0
}

secureUserInput() {
  question="${@}"
  SECUREINPUT="false"
  REPLY="alsofalse"
  while [ "${SECUREINPUT}" != "${REPLY}" ]; do
    read -s -p "${question} "
    echo
    SECUREINPUT="${REPLY}"
    read -s -p "Please enter it again: "
    echo
    if [ "${SECUREINPUT}" != "${REPLY}" ]; then
      echo
      echo "The two entries do not match."
      echo
    else
      echo
      echo "The two entries match. Continuing."
      echo
      return 0
    fi
  done
}

skip_it() {
  skipit="yes"
}

prepare_bintar_and_source_packages() {
  create_bintar="yes"
}

prepare_Windows_packages() {
  create_win="yes"
}

rsync_the_debian_repo() {
  rsync_debian_repo="yes"
}

rsync_the_ubuntu_repo() {
  rsync_ubuntu_repo="yes"
}

prepare_Debian_packages() {
  create_debian="yes"
}

prepare_Ubuntu_packages() {
  create_ubuntu="yes"
}

prepare_yum_packages() {
  create_yum="yes"
}

include_Galera_packages_in_repositories() {
  incl_galera="yes"
}

create_a_template_file() {
cat >> ${dir_conf}/prep.conf <<END
#-------------------------------------------------------------------------------
# default conf file for the MariaDB 'prep' script
#-------------------------------------------------------------------------------
# The 'prep' script is part of mariadb.org-tools on GitHub
#   git clone https://github.com/MariaDB/mariadb.org-tools.git

# Please edit and put in valid paths

# Full path to where buildbot saves files
dir_archive="/path/to/archive/pack"

# Full path to where various packages are located
dir_galera="/path/to/galera"
dir_jemalloc="/path/to/jemalloc" # Location of jemalloc pkgs
dir_nmap="/path/to/nmap" # nmap pkg for sles12
dir_at="/path/to/advance-toolchain" # Location of at pkgs
dir_rpm_shared="/path/to/shared/rpm/dir"
dir_judy="/path/to/judy" # Location of judy pkgs
dir_libzstd="/path/to/libzstd" # Location of libzstd pkgs
dir_docker="/path/to/docker/repo" # Location of corporation docker repo
dir_docker_library="/path/to/docker/repo2" # Location of docker library repo
dir_docker_library_official_images="/path/to/docker/repo3" # Location of official images path

dir_maxscale="/path/to/maxscale" # Location of maxscale pkgs

dir_bundles="/path/to/bundles/TX" # where bundle tarballs should be saved

ver_galera="25.3.x"                        # galera version[s] in our repos
ver_galera_preferred="25.3.x"              # preferred galera version
ver_galera4="26.4.x"                        # galera4 version[s] in our repos
ver_galera4_preferred="26.4.x"              # preferred galera4 version
ver_nmap="6.25"                             # current nmap ver in sles12 repo
  
# Full paths to the mkrepo-* scripts
DEBIAN="/path/to/mariadb.org-tools/release/mkrepo-debian.sh"
UBUNTU="/path/to/mariadb.org-tools/release/mkrepo-ubuntu.sh"
   YUM="/path/to/mariadb.org-tools/release/mkrepo-yum.sh"
   CPT="/path/to/mariadb.org-tools/release/create_package_tarballs"
 BNDLS="/path/to/mariadb.org-tools/release/prep-bundles"
GEN_UPDATEINFO="/path/to/mariadb.org-tools/release/gen-updateinfo.sh"

# Full path to the galera-* scripts
GALERA_NEW="/path/to/mariadb.org-tools/release/galera-new"

# URL where Windows Builds are located
winbuilder="http://example.net/builds"

# Default gpg options, including the key to use
     gpg_key="0xcbcb082a1bb943db"
    gpg_opts="--quiet -u 0xcbcb082a1bb943db --detach-sign --armor"

 gpg_key_2016="0xF1656F24C74CD1D8" # 2016-03-30 mariadb.org signing key
gpg_opts_2016="--quiet -u 0xF1656F24C74CD1D8 --detach-sign --armor"

 ent_gpg_key="0xce1a3dd5e3c94f49"
ent_gpg_opts="--quiet -u 0xce1a3dd5e3c94f49 --detach-sign --armor"

# Full paths to where the script should store releases
    dir_release="/path/to/mariadb/releases"
       dir_corp="/path/to/corp/releases"
      dir_tools="/path/to/tools/releases"
dir_release_ent="/path/to/mariadb-enterprise/releases"
   dir_yum_prep="/path/to/where/to/prep/yum/repos"

# Full path to P8 builds (if needed)
dir_archive_p8="/path/to/p8/archive/builds"

# ssh key to use for uploading
ssh_upload_key='.ssh/KEY_NAME'

# remote server information
buildmaster="buildmaster_ssh"
staging_mirror="mirror_ssh"
primary_mirror="mirror_ssh"
primary_mirror_rsync="rsync_addr_of_primary_mirror"
corp_mirror="mirror_ssh"
corp_mirror_path="/dest/dir/on/corp/mirror"
corp_bundles_path="/home/mariadb-repos/bundles/TX"
corp_tools_path="/home/mariadb-repos/mariadb-enterprise-tools"
yum_primary_mirror="bb01"
yum_mirrors="mirror names"
yum_mirror_path="/dest/dir/on/yum/mirror"

# Connectors
cj_home="/path/to/connector/java/home"
cj_home_corp="remote_home"
cc_home="/path/to/connector/c/home"
cc_home_corp="remote_home"
co_home="/path/to/connector/odbc/home"
co_home_corp="remote_home"

# vim: filetype=sh

END
chown ${USER}: ${dir_conf}/prep.conf
}

logSettings() {
cat >> ${dir_log}/prep.log <<END

# Prepped $(date)
# Command:
#   $0 -${log_displayusage}${log_demo}${log_run_script}${log_log}${log_is_ent}${log_is_cluster} -t ${tree} -r ${rev} -v ${num} -b ${tarbuildnum} 
# tree="${tree}"
# rev="${rev}"
# num="${num}"
# tarbuildnum="${tarbuildnum}"
# version="${version}"
# dir_release/dir_name="${dir_release}/${dir_name}"
# is_ent="${is_ent}"
# is_cluster="${is_cluster}"
# create_bintar="${create_bintar}"
# create_win="${create_win}"
# create_debian="${create_debian}"
# create_ubuntu="${create_ubuntu}"
# create_yum="${create_yum}"
# incl_galera="${incl_galera}"
# dir_archive="${dir_archive}"
# dir_galera="${dir_galera}"
# DEBIAN="${DEBIAN}"
# UBUNTU="${UBUNTU}"
# YUM="${YUM}"
# winbuilder="${winbuilder}"
# dir_archive_p8="${dir_archive_p8}"
# gpg_opts="${gpg_opts}"

END
chown ${USER}: ${dir_conf}/prep.conf
}

pressAnyKeyToContinue() {
  echo
  read -p "Press any key to continue." -n 1
  echo
  return 0
}

readyToSign() {
  local cont
  cont=""
}

shouldI() {
  local cont
  cont=""
   while [ -z ${cont} ]; do
     userResponse "Should I ${@//_/ }? [y/n]"
     case ${ANSWER} in
      "y")
        ${@}
        cont="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "Skipping . . . "
        cont="yes"
        ANSWER=""
        return 0
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        cont=""
        ;;
    esac
  done
}



loadDefaults() {
  # Load the paths (if they exist)
  if [ -f ${dir_conf}/prep.conf ]; then
      . ${dir_conf}/prep.conf
  else
    echo
    echo "The file ${dir_conf}/prep.conf does not exist in your home"
    echo "directory. If it does not exist, and have valid settings in it,"
    echo "this script will fail. I can create a default template file for you"
    echo "to fill out. Afterwards, please re-run this script."
    echo
    shouldI create_a_template_file
    # after creating the file, check if it exists again, if not, exit
    if [ ! -f ${dir_conf}/prep.conf ]; then
      echo "I was unable to create ${dir_conf}/prep.conf"
      echo "Exiting..."
      exit 3
    else
      echo
      echo "Template file created at ${dir_conf}/prep.conf"
      echo "Please edit and re-run this script."
      echo
      exit 0
    fi
  fi
}

usage() {
  set +x
  echo
  echo
  echo "usage: $0 -y[deghl] -t <tree> -r <revision> -v <version> -b <tarbuildnum>"
  echo "  -y : actually run the script"
  echo "  -d : run the script in demo mode"
  echo "  -e : this is a MariaDB Enterprise release"
  echo "  -g : this is a MariaDB Galera Cluster or Enterprise Cluster release"
  echo "  -h : display this usage message"
  echo "  -l : log the <tree>, <revision>, <tarbuildnum>, & etc... to ${dir_log}/prep.log"
  echo "  -t <tree> : the MariaDB source code tree"
  echo "  -r <revision> : the MariaDB source code tree revision"
  echo "  -v <version> : the MariaDB version number"
  echo "  -b <tarbuildnum> : the Buildbot tarbuildnum"
  echo
  echo
  set -x
}

thickline() {
  echo "==============================================================================="
}

line() {
  echo "-------------------------------------------------------------------------------"
}

important_message() {
  message="${@}"
  echo;echo;thickline;echo "+ ${message}";thickline;
}

message() {
  message="${@}"
  line;echo "+ ${message}";line;
}

lowkey_message() {
  message="${@}"
  echo -e "+ ${message}"
}


#---  FUNCTION  ----------------------------------------------------------------
#          NAME:  rsync_wrapper
#   DESCRIPTION:  This function provides a safety net for using rsync. It takes
#                 the options part of the rsync (everything that would come
#                 after the rsync command itself on the command-line) and first
#                 runs it with the --dry-run flag. It then asks if everything
#                 is OK. Assuming things are OK, it runs the rsync for real.
#-------------------------------------------------------------------------------
rsync_wrapper() {
  local upload
  upload=""
  rsync_body="${@}"
  lowkey_message "Doing a dry run..."
  set -x
  rsync --dry-run ${rsync_body}
  set +x
  echo
  while [ -z ${upload} ]; do
    userResponse "Does the above look OK? [y/n]"
    case ${ANSWER} in
      "y")
        lowkey_message "Transferring for real..."
        set -x
        rsync ${rsync_body}
        set +x
        echo
        upload="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "+ Something went wrong..."
        ANSWER=""
        exit 1
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        upload=""
        ;;
    esac
  done
}

rsync_wrapper_staging() {
  local upload_staging
  upload_staging=""
  rsync_body_staging="${@}"
  lowkey_message "Doing a dry run..."
  set -x
  ssh -t -t ${staging_mirror} "rsync --dry-run ${rsync_body_staging}"
  set +x
  echo
  while [ -z ${upload_staging} ]; do
    userResponse "Does the above look OK? [y/n]"
    case ${ANSWER} in
      "y")
        message "Transferring for real..."
        set -x
        ssh -t -t ${staging_mirror} "rsync ${rsync_body_staging}"
        set +x
        echo
        upload_staging="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "+ Something went wrong..."
        ANSWER=""
        exit 1
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        upload_staging=""
        ;;
    esac
  done
}

rsync_wrapper_primary() {
  local upload_primary
  upload_primary=""
  rsync_body_primary="${@}"
  lowkey_message "Doing a dry run..."
  set -x
  ssh -t -t ${primary_mirror} "rsync --dry-run ${rsync_body_primary}"
  set +x
  echo
  while [ -z ${upload_primary} ]; do
    userResponse "Does the above look OK? [y/n]"
    case ${ANSWER} in
      "y")
        lowkey_message "Transferring for real..."
        set -x
        ssh -t -t ${primary_mirror} "rsync ${rsync_body_primary}"
        set +x
        echo
        upload_primary="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "+ Something went wrong..."
        ANSWER=""
        exit 1
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        upload_primary=""
        ;;
    esac
  done
}


#===  FUNCTION  ================================================================
#          NAME:  upload_this_release_to_the_buildmaster
#   DESCRIPTION:  Transfer files from the local host to the buildmaster
#===============================================================================
upload_this_release_to_the_buildmaster() {
  important_message "Transferring files from here to the ${buildmaster}"
  message "Uploading release to ${buildmaster}..."
  rsync_wrapper "-av --delete-before ${dir_release}/${dir_name} ${buildmaster}:${dir_release}/"

  shouldI update_the_STATUS_file

  message "Uploading corp release to ${buildmaster}..."
  rsync_wrapper "-av --delete-before ${dir_corp}/${dir_name} ${buildmaster}:${dir_corp}/"
  # All done
}

#===  FUNCTION  ================================================================
#          NAME:  update_the_STATUS_file
#   DESCRIPTION:  Simple function to update a STATUS file with a UNIX timestamp
#===============================================================================
update_the_STATUS_file() {
  ssh ${buildmaster} "set -x ; bin/STATUS_update"
  lowkey_message "STATUS file updated"
}

#===  FUNCTION  ================================================================
#          NAME:  pull_this_release_from_the_buildmaster
#   DESCRIPTION:  Transfer files over from the buildmaster before prepping
#===============================================================================
pull_this_release_from_the_buildmaster() {
  # This function enables prepping a release remotely. To be able to do this we
  # need to:
  # - Fix permissions on the buildmaster
  # - rsync the needed dirs from the buildmaster such that they can all be
  #   found at the same paths on the local machine
  # - Possibly not upload to the staging mirror (because we might be doing this
  #   on the staging mirror)

  # First set the remote_prep variable to yes so that other parts of the script
  # know what is going on
  remote_prep="yes"
  ci_release=false

  important_message "Transferring files on ${buildmaster} to here"

  # Fix permissions on the buildmaster
  maybe_fix_permissions

  # Create the local directories if they don't exist
  lowkey_message "Making sure local directories exist..."
  if [ ! -d ${dir_archive}/${tree}/build-${tarbuildnum} ]; then
    mkdir -vp ${dir_archive}/${tree}/build-${tarbuildnum}
  fi

  if [ ! -d ${dir_archive_p8}/${tree}/${rev} ]; then
    mkdir -vp ${dir_archive_p8}/${tree}/${rev}
  fi
  echo

  # After the above is finished we should have something like:
  #   /ds413/archive/pack/10.4/build-25413
  #   /ds413/archive/builds/10.4/5da6944ea3a592efefd1adc33b1280ad1de66688

  # We can now rsync the builds from the buildmaster
  message "Transferring kvm builds from ${buildmaster}..."
  rsync_wrapper "-av --delete-before ${buildmaster}:${dir_archive}/${tree}/build-${tarbuildnum}/ ${dir_archive}/${tree}/build-${tarbuildnum}/"

  #message "Transferring other builds from ${buildmaster}..."
  #rsync_wrapper "-av --delete-before ${buildmaster}:${dir_archive_p8}/${tree}/${rev}/ ${dir_archive_p8}/${tree}/${rev}/"
 
  message "Transferring galera from ${buildmaster}..."
  for galera_version in ${ver_galera_real}; do
    rsync_wrapper "-av --delete-before ${buildmaster}:${dir_galera}/galera-${galera_version}* ${dir_galera}/"
  done
  #rsync_wrapper "-av --delete-before ${buildmaster}:${dir_galera}/galera-${galera_version}-signed ${dir_galera}/"
  #rsync_wrapper "-av --delete-before ${buildmaster}:${dir_galera}/galera-${galera_version}-signed-ent ${dir_galera}/"

  # We should be done now

}

pull_this_release_from_ci() {
  remote_prep="yes"
  #ci_release=true
  important_message "Transferring files on ${ci} to here"

  lowkey_message "Making sure local directories exist..."

  if [ ! -d ${dir_archive}/ci/${tree}/${ci_tarbuildnum} ]; then
    mkdir -vp ${dir_archive}/ci/${tree}/${ci_tarbuildnum}
  fi

  runCommand pushd ${dir_archive}/ci/${tree}

    message "Transferring builds from ${ci}..."
    set +e
    for ci_pair in ${!ci_dirs} ; do
      ci_dir=(${ci_pair//:/ })
    if runCommand wget --no-parent -r -N --no-host-directories --exclude-directories=logs ${ci}/${ci_tarbuildnum}/${ci_dir[1]}/ ; then
      message "Downloaded ${ci_dir[1]} from ci"
    else
      runCommand wget --cut-dirs=1 --no-parent -r -N --no-host-directories --exclude-directories=logs ${ci}/older_builds/${ci_tarbuildnum}/${ci_dir[1]}/
    fi
    done
    set -e
    runCommand find ${ci_tarbuildnum}/ -name "index.html" -exec rm -v {} \;

  runCommand popd
  #runCommand tree ${dir_archive}/ci/${tree}/${ci_tarbuildnum}
  runCommand tree -L 1 ${dir_archive}/ci/${tree}/${ci_tarbuildnum}
  message "Done downloading release to ${dir_archive}/ci/${tree}/${ci_tarbuildnum}"
  shouldI verify_the_ci_download
}

verify_all_needed_ci_dirs_are_present() {
  message "Checking for presence of all needed ci builds..."
  should_I_quit=0
  for ci_pair in ${!ci_dirs}; do
    ci_dir=(${ci_pair//:/ })
    dir_source=${dir_archive}/ci/${tree}/${ci_tarbuildnum}/${ci_dir[1]}
    if [ -d ${dir_source} ]; then
      lowkey_message "\e[32m✔  ${ci_dir[1]}\e[0m"
    else
      lowkey_message "\e[31m⚠  ${ci_dir[1]}\e[0m"
      should_I_quit=1
    fi
  done
  if ((${should_I_quit})) ; then
    important_message "Some needed builds are missing, quitting..."
    exit 8
  fi
}

verify_all_needed_dirs_are_present() {
  message "Checking for presence of all needed builds..."
  should_I_quit=0
  for dir_pair in ${!full_dirs}; do
    needed_dir=(${dir_pair//:/ })
    dir_source=${dir_archive}/${tree}/build-${tarbuildnum}/${needed_dir[0]}
    if [ -d ${dir_source} ]; then
      lowkey_message "\e[32m✔  ${needed_dir[0]}\e[0m"
    else
      lowkey_message "\e[31m⚠  ${needed_dir[0]}\e[0m"
      should_I_quit=1
    fi
  done
  if ((${should_I_quit})) ; then
    important_message "Some needed builds are missing, quitting..."
    exit 8
  fi
}

copy_ci_downloads_to_buildmaster_dir() {
  verify_all_needed_ci_dirs_are_present
  message "Copying needed builds from ${dir_archive}/ci/${tree}/${ci_tarbuildnum} to ${dir_archive}/${tree}/build-${tarbuildnum}/"

  for ci_pair in ${!ci_dirs}; do
    ci_dir=(${ci_pair//:/ })
    dir_source=${dir_archive}/ci/${tree}/${ci_tarbuildnum}/${ci_dir[1]}
    dir_dest=${dir_archive}/${tree}/build-${tarbuildnum}/${ci_dir[0]}
    if [ -d ${dir_dest} ]; then
      message "${dir_dest} already exists, moving..."
      runCommand mv -vi ${dir_dest} ${dir_dest}_orig
    fi
    if [ -d ${dir_source} ]; then
      runCommand cp -ai ${dir_source} ${dir_dest}
    else
      important_message "${dir_source} does not exist"
      exit 1
    fi
  done
}


#===  FUNCTION  ================================================================
mark_this_release_as_a_ci_release() {
  ci_release=true
}

verify_the_ci_download() {
  message "Verifying files downloaded from ${ci}..."
  for shafile in $(find ${dir_archive}/ci/${tree}/${ci_tarbuildnum} -name sha256sums.txt) ; do
    runCommand pushd $(dirname ${shafile})
    case $shafile in
      *windows*)
        dos2unix sha256sums.txt
        sed -i 's/[ \t]*$//' sha256sums.txt
        sed -i '/^$/d' sha256sums.txt
        ;;
    esac
    runCommand sha256sum --quiet -c sha256sums.txt
    runCommand popd
    line
  done
}

use_the_staging_mirror() {
  skip_staging="no"
}

start_the_ssh-agent() {
  # start the ssh-agent and add the upload key
  lowkey_message "Starting the ssh-agent.."
  eval $(ssh-agent)
  ssh-add ${ssh_upload_key}
}


#===  FUNCTION  ================================================================
#          NAME:  upload_the_bundles_to_the_staging_mirror
#   DESCRIPTION:  Transfer bundles to the staging mirror
#===============================================================================
upload_the_bundles_to_the_staging_mirror() {
  rsync_wrapper "-av --delete-before ${dir_bundles}/mariadb*${num}* ${staging_mirror}:${dir_bundles}/"
}

#===  FUNCTION  ================================================================
#          NAME:  upload_bundles_from_the_staging_mirror_to_the_corp_mirror
#   DESCRIPTION:  Sync the release from the primary public mirror to the corp
#                 mirror
#===============================================================================
upload_bundles_from_the_staging_mirror_to_the_corp_mirror() {
  rsync_wrapper_staging "-av --delete-before ${dir_bundles}/mariadb*${num}* ${corp_mirror}:${corp_bundles_path}/"
}

#===  FUNCTION  ================================================================
#          NAME:  upload_to_the_staging_mirror
#   DESCRIPTION:  Transfer the release to the staging mirror
#===============================================================================
upload_to_the_staging_mirror() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${version_nog} ${dir_release}/${dir_name} ${staging_mirror}:${dir_release}/"
  else
    rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${dir_name} ${staging_mirror}:${dir_release}/"
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  copy_the_previous_release_to_the_current_release_on_the_mirrors
#   DESCRIPTION:  There are a lot of duplicated files from previous releases in
#                 every new release. These include previous package versions
#                 that are included in the repositories, the galera folder, and
#                 other stuff. This function copies old releases to the new
#                 release so that we don't have to re-upload files that we
#                 don't need to. When we then do the actual upload of the new
#                 release, rsync takes care of deleting the files that actually
#                 aren't part of the new release.
#===============================================================================
copy_the_previous_release_to_the_current_release_on_the_mirrors() {
  if [ ! ${prev_release} ] ; then
    set_prev_release
  fi

  echo;echo

  message "Primary Mirror"
  ssh -t -t ${primary_mirror} "set -x ; rsync -a --info=progress2 --exclude=source --exclude='win*packages' --exclude='bintar*' --exclude=repodata --exclude=db --exclude=dists data/mariadb-${prev_release}/ data/${dir_name}/"

  echo;echo

  message "Corp Mirror Staging"
  ssh -t -t ${corp_mirror} "set -x; rsync -a --info=progress2 --exclude=source --exclude='win*packages' --exclude='bintar*' --exclude=repodata --exclude=db --exclude=dists ${corp_mirror_path}/mariadb-${prev_release}/ ${corp_mirror_path_staging}/${dir_name}/"

  echo;echo

  message "Yum Mirror"
  ssh -t -t ${yum_primary_mirror} "set -x ; rsync -a --info=progress2 --exclude=repodata --exclude=db --exclude=dists ${yum_mirror_path}/${prev_release}/ ${yum_mirror_path}/${num}/"

  echo;echo

  message "Done copying previous release to the current release on the mirrors"
}

#===  FUNCTION  ================================================================
#          NAME:  copy_release_dir_to_corp_dir_so_corp_upload_is_smaller
#   DESCRIPTION:  corp and org release dirs are similar, so copying from one to
#                 the other before doing the corp upload saves bandwidth
#===============================================================================
copy_release_dir_to_corp_dir_so_corp_upload_is_smaller() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${version_nog} ${dir_release}/${dir_name} ${dir_corp}/"
  else
    rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${dir_name} ${dir_corp}/"
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  upload_corp_dir_to_the_staging_mirror
#   DESCRIPTION:  Transfer the corp release to the staging mirror
#===============================================================================
upload_corp_dir_to_the_staging_mirror() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${version_nog} ${dir_corp}/${dir_name} ${staging_mirror}:${dir_corp}/"
  else
    rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${dir_name} ${staging_mirror}:${dir_corp}/"
  fi
}


#===  FUNCTION  ================================================================
#          NAME:  upload_to_the_primary_mirror
#   DESCRIPTION:  Transfer the release from the staging mirror to the primary
#                 mirror
#===============================================================================
upload_to_the_primary_mirror() {
  if [ "${skip_staging}" = "yes" ]; then
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${version_nog} ${dir_release}/${dir_name} ${primary_mirror}:data/"
    else
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${dir_name} ${primary_mirror}:data/"
    fi
  else
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${version_nog} ${dir_release}/${dir_name} ${primary_mirror}:data/"
    else
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${dir_name} ${primary_mirror}:data/"
    fi
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  upload_to_the_yum_mirrors
#   DESCRIPTION:  Transfer files from the primary mirror to the yum repository
#                 mirrors
#===============================================================================
upload_to_the_yum_mirrors() {
  # After the staging mirror has the files, rsync to the bb boxes:
  set -x
  ssh -t -t ${yum_primary_mirror} "if [ ! -d '${yum_mirror_path}/${num}' ];then mkdir -v ${yum_mirror_path}/${num};fi" 
  set +x

  if [ "${skip_staging}" = "yes" ]; then
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${version_nog}/yum/ ${yum_primary_mirror}:${yum_mirror_path}/${num}/"
    else
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${dir_name}/yum/ ${yum_primary_mirror}:${yum_mirror_path}/${num}/"
    fi
  else
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${version_nog}/yum/ ${yum_primary_mirror}:${yum_mirror_path}/${num}/"
    else
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_release}/${dir_name}/yum/ ${yum_primary_mirror}:${yum_mirror_path}/${num}/"
    fi
  fi

  set -x
  for yum_mirror in ${yum_mirrors} ;do 
    ssh -t -t ${yum_primary_mirror} "set -x;rsync -a --info=progress2 --delete-before ${yum_mirror_path}/${num} ${yum_mirror}:${yum_mirror_path}/"; 
  done
  set +x
}

#===  FUNCTION  ================================================================
#          NAME:  activate_the_yum_repos
#   DESCRIPTION:  Run the commands necessary to make the repository files public
#===============================================================================
activate_the_yum_repos() {
  if [ "${galera_suffix}" = "-galera" ]; then
    # Do nothing if this is a galera release
    echo "This is a galera release, skipping this step..."
  else
    echo;echo;
    set -x
    for yum_mirror in ${yum_primary_mirror} ${yum_mirrors} ;do 
      ssh -t -t ${yum_mirror} "cd ${yum_mirror_path}/;rm -v ${major};ln -sv ${num} ${major};echo;echo"; 
    done
    set +x
  fi
  ssh -t -t ${primary_mirror} "set -x ; cd data/yum ; ls -l ; rm -v ${major} ; ln -sv ../${version_nog}/yum ${major} ; ls -l";
  set -x
  ssh -t -t ${primary_mirror} "./trigger-mariadb";
  set +x
}

#===  FUNCTION  ================================================================
#          NAME:  activate_the_deb_repos
#   DESCRIPTION:  Run the commands necessary to make the repository files public
#===============================================================================
activate_the_deb_repos() {
  set -x
  set +x
  ssh -t -t ${primary_mirror} "set -x ; cd data/repo ; ls -l ; rm -v ${major} ; ln -sv ../${version_nog}/repo ${major} ; ls -l";
  set -x
  ssh -t -t ${primary_mirror} "./trigger-mariadb";
  set +x
}

#===  FUNCTION  ================================================================
#          NAME:  activate_the_corp_repos
#   DESCRIPTION:  Run the commands necessary to make the repository files public
#===============================================================================
activate_the_corp_repos() {
  if [ "${galera_suffix}" = "-galera" ]; then
    # Do nothing if this is a galera release
    echo "This is a galera release, skipping this step..."
  else
    echo;echo;
    set -x
    ssh -t -t ${corp_mirror} "set -x;cd ${corp_mirror_path}/;rm -v mariadb-${major};ln -sv ${dir_name} mariadb-${major};echo;echo";
    set +x
  fi
}

create_package_tarballs() {
  set -x
  pushd ${CPT}
  ./create_package_tarballs ${dir_corp}/${version_nog}/
  popd
  set +x
  pushd ${dir_corp}/${version_nog}
    tarfiles=$(find . -name '*.tar')
    for tarfile in ${tarfiles}; do
      echo;echo;line;echo "+ ${tarfile}";line;tar -tf ${tarfile}
      if ! tar -tf ${tarfile} | grep galera &>/dev/null
      then
        echo "+ ERROR: galera package missing from ${tarfile}"
        exit 1
      else
        echo "+ INFO: galera package present in ${tarfile}"
      fi
    done
  popd
}

create_bundles() {
  message "Creating the ${num} bundles"
  ${BNDLS} ${num}
  message "Done creating the ${num} bundles!"
}

bundles() {
  local bundle
  bundle=""
   while [ -z ${bundle} ]; do
     userResponse "Does this release have bundles? [y/n]"
     case ${ANSWER} in
      "y")
        ${@}
        bundle="yes"
        ANSWER=""

        shouldI create_bundles

        echo;echo;echo;echo

        shouldI upload_the_bundles_to_the_staging_mirror

        echo;echo;echo;echo

        shouldI upload_bundles_from_the_staging_mirror_to_the_corp_mirror

        return 0
        ;;
      "n")
        echo "Skipping . . . "
        bundle="yes"
        ANSWER=""
        return 0
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        bundle=""
        ;;
    esac
  done
}


#===  FUNCTION  ================================================================
#          NAME:  upload_to_the_corp_mirror_staging_dir
#   DESCRIPTION:  Sync the release from the primary public mirror to the corp
#                 mirror staging directory
#===============================================================================
upload_to_the_corp_mirror_staging_dir() {
  if [ "${skip_staging}" = "yes" ]; then
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${version_nog} ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path_staging}/"
    else
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path_staging}/"
    fi
  else
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${version_nog} ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path_staging}/"
    else
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path_staging}/"
    fi
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  activate_the_corp_staging_repos
#   DESCRIPTION:  Run the commands necessary to make the repository files public
#===============================================================================
activate_the_corp_staging_repos() {
  if [ "${galera_suffix}" = "-galera" ]; then
    # Do nothing if this is a galera release
    echo "This is a galera release, skipping this step..."
  else
    echo;echo;
    set -x
    ssh -t -t ${corp_mirror} "set -x;cd ${corp_mirror_path_staging}/;rm -v mariadb-${major};ln -sv ${dir_name} mariadb-${major};echo;echo";
    set +x
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  copy_corp_staging_to_prod
#   DESCRIPTION:  No need to reupload everything if the corp staging dir already
#                 has a lot of what we need
#===============================================================================

copy_the_corp_mirror_staging_dir_to_prod() {
  ssh ${corp_mirror} "if [[ -d ${corp_mirror_path_staging}/${dir_name} ]]; then if [[ ! -d ${corp_mirror_path}/${dir_name} ]]; then set -x;cp -ail ${corp_mirror_path_staging}/${dir_name} ${corp_mirror_path}/;else echo '+ Found existing ${dir_name} under ${corp_mirror_path}/, not copying...';fi;else echo '+ ${dir_name} not found under ${corp_mirror_path_staging}/, not copying...';fi"
}


#===  FUNCTION  ================================================================
#          NAME:  upload_to_the_corp_mirror
#   DESCRIPTION:  Sync the release from the primary public mirror to the corp
#                 mirror
#===============================================================================
upload_to_the_corp_mirror() {
  if [ "${skip_staging}" = "yes" ]; then
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${version_nog} ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path}/"
    else
      rsync_wrapper "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path}/"
    fi
  else
    if [ "${galera_suffix}" = "-galera" ]; then
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${version_nog} ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path}/"
    else
      rsync_wrapper_staging "-av --delete-before --exclude=exclude --exclude=*orig ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path}/"
    fi
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  maybe_create_release_dir
#   DESCRIPTION:  Create the release dir if it doesn't exist
#===============================================================================
maybe_create_release_dir() {
  if [ ! -d ${dir_release}/${dir_name} ]; then
    echo
    line
    echo "+ creating release dir..."
    line
    mkdir -v ${dir_release}/${dir_name}
    echo
  fi
  if [ ! -d ${dir_corp}/${dir_name} ]; then
    echo
    line
    echo "+ creating corp release dir..."
    line
    mkdir -v ${dir_corp}/${dir_name}
    echo
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  maybe_fix_permissions
#   DESCRIPTION:  Fix permissions on the buildbot dirs, if they haven't been
#                 fixed already during this run of the script
#===============================================================================
maybe_fix_permissions() {
  if [ "${perms_fixed}" = "no" ]; then
     message "fixing permissions..."

    dirs_to_chmod="${dir_archive}/${tree}/ ${dir_archive}/${tree}/build-${tarbuildnum}/ ${dir_archive_p8}/${tree}/ ${dir_archive_p8}/${tree}/${rev}"

    if [ "${remote_prep}" = "yes" ]; then

      # If we're fixing remote permissions, we want to to it with one ssh
      # connection, so everything goes on one line

      ssh -t -t ${buildmaster} "if [ ! -d ${dir_archive_p8}/${tree}/${rev} ]; then sudo mkdir -vp ${dir_archive_p8}/${tree}/${rev};fi;" "sudo chmod -c 755 ${dirs_to_chmod};" 'for dir  in $(sudo find' ${dir_archive}/${tree}/build-${tarbuildnum}/ '-type d);do sudo chmod -c 755 ${dir};done;' 'for file in $(sudo find' ${dir_archive}/${tree}/build-${tarbuildnum}/ '-type f);do sudo chmod -c 644 ${file};done;' 'for dir  in $(sudo find' ${dir_archive_p8}/${tree}/${rev}/ '-type d);do sudo chmod -c 755 ${dir};done;' 'for file in $(sudo find' ${dir_archive_p8}/${tree}/${rev}/ '-type f);do sudo chmod -c 644 ${file};done'

    else
      # If we're here we are not fixing remote permissions, so we can do things
      # on separate lines, which makes everything more readable

      # Make sure parent dirs are OK first
      sudo chmod -c 755 ${dirs_to_chmod}

      # scan and adjust perms of subdirs
      for dir in $(sudo find ${dir_archive}/${tree}/build-${tarbuildnum}/ -type d);do
        sudo chmod 755 "${dir}"
      done
      for file in $(sudo find ${dir_archive}/${tree}/build-${tarbuildnum}/ -type f);do
        sudo chmod 644 "${file}"
      done
      for dir in $(sudo find ${dir_archive_p8}/${tree}/${rev}/ -type d);do
        sudo chmod 755 "${dir}"
      done
      for file in $(sudo find ${dir_archive_p8}/${tree}/${rev}/ -type f);do
        sudo chmod 644 "${file}"
      done
    fi

    perms_fixed="yes" # set perms_fixed to 'yes' so this doesn't run again

    echo "+ done fixing permissions"
    echo
  fi
}


#---  FUNCTION  ----------------------------------------------------------------
#          NAME:  pull_the_win_packages_from_the_win_builder
#   DESCRIPTION:  Should we pull the the Windows packages from the builder or
#                 are they already on the local filesystem?
#-------------------------------------------------------------------------------
pull_the_win_packages_from_the_win_builder() {
  win_remote=true
}

#===  FUNCTION  ================================================================
#          NAME:  display_the_previous_yum_directory
#   DESCRIPTION:  A simple function to list (using tree) the contents of the
#                 previous release's yum directory. Useful for seeing what
#                 releases are in it.
#===============================================================================
display_the_previous_yum_directory() {
  echo; line;
  echo "Here is the previous yum directory:"
  line; echo
  tree ${dir_release}/mariadb-${prev_release}/yum
  echo;echo;echo;
  pressAnyKeyToContinue
}

#===  FUNCTION  ================================================================
#          NAME:  exclude_an_old_release_from_the_yum_dir
#   DESCRIPTION:  This function sets the exclude_release variable. If this
#                 variable is set to something non-zero then the rsync that
#                 handles the yum repo will exclude it.
#===============================================================================
exclude_an_old_release_from_the_yum_dir() {
  userInput "What release should I exclude? (e.g. 10.2.13)"
  exclude_release="${INPUT}"
}

#===  FUNCTION  ================================================================
#          NAME:  update_the_docker_library_mariadb_version
#   DESCRIPTION:  This function creates a pull request to the Docker Library
#                 people to do a release, after Ubuntu focus/jammy has been pushed
#                 to the archive mirror.
#===============================================================================
update_the_docker_library_mariadb_version() {
  if ! command -v bashbrew
  then
    runCommand wget https://github.com/docker-library/bashbrew/releases/download/v0.1.3/bashbrew-amd64 -O ~/bin/bashbrew
    runCommand chmod a+x ~/bin/bashbrew
  fi
  if [ ! -d ${dir_docker_library_official_images} ]; then
    # fork from https://github.com/docker-library/official-images
    runCommand git clone git@github.com:dbart/official-images ${dir_docker_official_images}
  fi
  export BASHBREW_LIBRARY=${dir_docker_library_official_images}
  if [ ! -d ${dir_docker_library} ]; then
    runCommand git clone git@github.com:MariaDB/mariadb-docker ${dir_docker}
  fi
  pushd ${dir_docker_library}
    runCommand git fetch
    runCommand git checkout master
    runCommand git pull
    runCommand git merge orgin/next
    runCommand ./update.sh
    # This should show the new release in all versions
    runCommand git diff
    runCommand git add [0-9]*
    if git commit -m "MariaDB Server releases ${reldate}" ; then
      echo "+ git commit -m \"MariaDB Server ${reldate}\""
      runCommand git push
    fi
    message "Check https://github.com/MariaDB/mariadb-docker
the top commit above the directory listing should have a dot for the CI that
will eventually run through to be green"
    pressAnyKeyToContinue
  popd
  # prepare the release
  pushd ${dir_docker_library_official_images}
    runCommand git checkout master
    runCommand git pull
    reldate=$(date +%Y%m%d)
    if git checkout -b mariadb-release-$reldate ; then
      echo "+ git checkout -b mariadb-release-$reldate"
    else 
      # if the checkout -b command fails that means the branch already exists,
      # so we can simply check it out with:
      runCommand git checkout mariadb-release-$reldate
    fi
    runCommand git remote prune origin
    message "The ${dir_docker_library_official_images} git repo is linked upstream to
the github.com/docker-library/official-images git repository. It was
added with:
  git remote add upstream git@github.com:docker-library/official-images.git
use the git remote command to check:
  git remote -v
Anyway, before doing anything else, let's merge with upstream to make
sure we have the latest from there before doing anything else:"
    runCommand git fetch upstream
    runCommand git merge upstream/master
    #runCommand git push --set-upstream origin mariadb-release-$reldate
    message "now we can continue"
    echo "+ ${dir_docker_library}/generate-stackbrew-library.sh | tee library/mariadb"
            ${dir_docker_library}/generate-stackbrew-library.sh | tee library/mariadb
    # note non-GA releases shouldn't have the latest or 10 tag
    runCommand git push --set-upstream origin mariadb-release-$reldate
    echo "+ git commit -m \"MariaDB releases ${reldate}\" library/mariadb"
           git commit -m "MariaDB releases ${reldate}" library/mariadb
    runCommand git push
    message "Follow Create a pull request for 'mariadb-release-${reldate}' on GitHub by
+ visiting link
+ e.g. https://github.com/dbart/official-images/pull/new/mariadb-release-${reldate}
+ This should be a pull request against the
+ https://github.com/docker-library/official-images repository. Write some
+ covering text e.g. see
+ https://github.com/docker-library/official-images/pull/10414 -and-
+ https://github.com/docker-library/official-images/pull/10070 for examples"
  popd
}
#===  FUNCTION  ================================================================
#          NAME:  set_prev_release
#   DESCRIPTION:  set the ${prev_release} var
#===============================================================================

set_prev_release() {
  userInput "What is the previous MariaDB release? (e.g. 10.1.1)"
  prev_release="${INPUT}"
}

#===  FUNCTION  ================================================================
#          NAME:  generate_the_file_list_pickle_for_org_downloads
#   DESCRIPTION:  This function logs in to the primary mirror and runs the
#                 command to generate the pickle that is then imported into the
#                 mariadb.org downloads system.
#===============================================================================
generate_the_file_list_pickle_for_org_downloads() {
  ssh -t -t ${primary_mirror} "python generate_file_list.py data/ --release=${dir_name}";
}

#-------------------------------------------------------------------------------
# Main Script
#-------------------------------------------------------------------------------

# The first thing we need to do is parse the options
while getopts 'b:c:deghlr:t:v:y' OPTION
do
  case $OPTION in
    d)  # Not implemented yet
      demo="yes"
      log_demo="d"
      ;;
    e)  # This is a MariaDB Enterprise or MariaDB Enterprise Cluster release
      is_ent="yes"
      log_is_ent="e"
      ;;
    g)  # This is a MariaDB Galera Cluster or Enterprise Cluster release
        # -e & -g both need to be set for a MariaDB Enterprise Cluster release
      galera_suffix="-galera"
      is_cluster="yes"
      log_is_cluster="g"
      ;;
    h)  # Display a helpful usage message
      displayusage="yes"
      log_displayusage="h"
      ;;
    l)  # Log the release to ${dir_log}/prep.log
      log="yes"
      log_log="l"
      ;;
    r)  # The release revision
      rev="${OPTARG}"
      revflag=true
      ;;
    t)  # The release tree
      tree="${OPTARG}"
      treeflag=true
      ;;
    v)  # The version number of this release
      num="${OPTARG}"
      numflag=true
      ;;
    b)  # The tarbuildnum of the release
      tarbuildnum="${OPTARG}"
      tarflag=true
      ;;
    c)  # The ci tarbuildnum of the release
      ci_tarbuildnum="${OPTARG}"
      tarflag=true
      ;;
    y)  # Actually run this script (helps prevent accidental runs)
      run_script="yes"
      log_run_script="y"
      ;;
    \?) # Display a helpful usage message
      displayusage="yes"
      ;;
    :)  # Error when an option is used that requires an argument
      displayusage="yes"
      echo "Option -$OPTARG requires an argument."
      ;;
  esac
done

shift $(($OPTIND - 1))

if ! ${revflag} || ! ${numflag} || ! ${treeflag} || ! ${tarflag} ; then
  #if [[ -d $1 ]]; then
    echo
    line
    echo "-r -t -v and -b, along with their appropriate arguments, are mandatory" >&2
    line
    usage
    exit 4
  #fi
fi

# make sure we are running as root
#if (( `id -u` != 0 )); then { echo "Sorry, ${0} must be run using sudo. Exiting..."; exit; } fi

# Display usage message and quit if necessary
if [ "${displayusage}" = "yes" ] || [ "${run_script}" != "yes" ]; then
  usage
  exit 0
fi

loadDefaults                                    # Load Default paths and vars

# create major variable that has the base major version of mariadb (e.g. 10.3)
major=${num%.*}

# set various ${xx_dirs} variables to the appropriate version
ci_dirs="ci_dirs_${major//./}"
bb_dirs="bb_dirs_${major//./}"
full_dirs="full_dirs_${major//./}"

# Set the real version of galera to use
case ${major} in
  10.2|10.3)
    ver_galera_real=${ver_galera}
    ver_galera_preferred_real=${ver_galera_preferred}
    ;;
  *)
    ver_galera_real=${ver_galera4}
    ver_galera_preferred_real=${ver_galera4_preferred}
    ;;
esac

# Put ${galera_suffix} and ${num} together to form the base version string
if [ "${is_ent}" = "yes" ];then
  if [ "${galera_suffix}" = "-galera" ]; then
    version="mariadb-enterprise-cluster-${num}"
  else
    version="mariadb-enterprise-${num}"
  fi
else
  version="mariadb${galera_suffix}-${num}"
  version_nog="mariadb-${num}"
fi

shouldI pull_this_release_from_the_buildmaster

shouldI pull_this_release_from_ci


shouldI copy_ci_downloads_to_buildmaster_dir

#shouldI mark_this_release_as_a_ci_release

shouldI verify_all_needed_dirs_are_present

important_message "Creating the ${version} Release"

shouldI prepare_bintar_and_source_packages
if [ "${galera_suffix}" != "-galera" ]; then
  shouldI prepare_Windows_packages
fi

case $tree in
  *5.5* )
    echo "+ no Debian for 5.5"
    shouldI rsync_the_debian_repo
    ;;
  *)
    shouldI prepare_Debian_packages
    ;;
esac

case $tree in
  *5.5* )
    echo "+ no Ubuntu for 5.5"
    shouldI rsync_the_ubuntu_repo
    ;;
  *)
    shouldI prepare_Ubuntu_packages
    ;;
esac

shouldI prepare_yum_packages
#shouldI include_Galera_packages_in_repositories
include_Galera_packages_in_repositories

set_build_dirs_variables

# Set various options that change depending on whether this is an enterprise
# release or not
if [ "${is_ent}" = "yes" ];then
  suffix="signed-ent"

  # new enterprise key (2014-12-18)
  gpg_opts="--quiet -u 0xce1a3dd5e3c94f49 --detach-sign --armor"

  dir_release="${dir_release_ent}"  # Default location for MariaDB Enterprise
  build_dirs="${ent_build_dirs_x86_64}" # Default dirs for MariaDB Enterprise

  if [ "${galera_suffix}" = "-galera" ]; then
    dir_name="${num}-cluster" # release directory name for Enterprise Cluster
  else
    dir_name="${num}"         # release directory name for MariaDB Enterprise
  fi
else
  suffix="signed"
  if ${ci_release}; then
    build_dirs="source:source ${ci_build_dirs_x86} ${ci_build_dirs_x86_64} ${ci_build_dirs_aarch64} ${ci_build_dirs_ppc64le}"
  else
  build_dirs="${build_dirs_x86} ${build_dirs_x86_64}" # Default dirs for MariaDB
  fi
  if [ "${tree}" = "10.0-FusionIO" ]; then
    dir_name="${version}-FusionIO" # FusionIO releases get a custom directory
  else
    dir_name="${version}" # normal releases use ${version} as ${dir_name}
  fi
  gpg_opts="--quiet -u 0xcbcb082a1bb943db --detach-sign --armor" 
  #gpg_opts="--quiet -u 0xF1656F24C74CD1D8 --detach-sign --armor" # new GPG key for Sid
fi

if [ ${log} = "yes" ]; then
  logSettings
fi

#exit 0;
#echo
#shouldI start_the_ssh-agent

echo
# start the gpg-agent if it's not already started
eval $(gpg-agent --daemon)




#-------------------------------------------------------------------------------
#  Binary Tarballs and Source
#-------------------------------------------------------------------------------
if [ "${create_bintar}" != "no" ]; then
  maybe_create_release_dir      # Create release dirs if they don't exist
  if ${ci_release}; then
  maybe_fix_permissions         # fix permissions if needed
  fi
  pushd ${dir_release}/${dir_name}
  line
  echo "+ transfering bintar & source packages..."
  line
  for dir_pair in ${build_dirs}; do
    dir_array=(${dir_pair//:/ })
    if [ -d ${dir_release}/${dir_name}/${dir_array[1]} ]; then
      echo "${dir_array[1]} already exists under ${dir_release}/${dir_name}/"
      shouldI skip_it
    fi
    if [ "${skipit}" = "yes" ]; then
      echo "${dir_array[1]} has been skipped"
      skipit="no"
      echo
    else
      # Not skipping
      if [ ! -d /run/shm/${dir_name}/${dir_array[1]} ]; then
        runCommand mkdir -vp /run/shm/${dir_name}/${dir_array[1]}
      fi
      case ${dir_array[1]} in
        'macOS')
          location="${dir_archive_p8}/${tree}/${rev}/${dir_array[0]}"
          ;;
        *)
          if ${ci_release}; then
            location="${dir_archive}/ci/${tree}/${tarbuildnum}/${dir_array[0]}"
            location_source="${dir_archive}/ci/${tree}/${tarbuildnum}"
          else
          location="${dir_archive}/${tree}/build-${tarbuildnum}/${dir_array[0]}"
            location_source="${location}"
          fi
          ;;
      esac
      if [ "${dir_array[1]}" = "source" ]; then
        if runCommand rsync ${rsync_opts} "${location_source}/mariadb-${num}.tar.gz" "/run/shm/${dir_name}/${dir_array[1]}/mariadb${galera_suffix}-${num}.tar.gz"; then
          pushd /run/shm/${dir_name}/${dir_array[1]}
          # rename the source tarball for enterprise
          if [ "${is_ent}" = "yes" ];then
            runCommand mv -vi mariadb${galera_suffix}-${num}.tar.gz mariadb-enterprise${galera_suffix}-${num}.tar.gz
          fi
          echo "+ updating source tarball md5sum..."
          if [ -e md5sums.txt ]; then
            runCommand rm -v md5sums.txt
          fi
          md5sum ./mariadb* >> md5sums.txt

          echo "+ updating source tarball sha1sum..."
          if [ -e sha1sums.txt ]; then
            runCommand rm -v sha1sums.txt
          fi
          sha1sum ./mariadb* >> sha1sums.txt

          echo "+ updating source tarball sha256sum..."
          if [ -e sha256sums.txt ]; then
            runCommand rm -v sha256sums.txt
          fi
          sha256sum ./mariadb* >> sha256sums.txt

          echo "+ updating source tarball sha512sum..."
          if [ -e sha512sums.txt ]; then
            runCommand rm -v sha512sums.txt
          fi
          sha512sum ./mariadb* >> sha512sums.txt

          echo "+ signing source tarball and sum files..."
          # remove any signature files before signing, if they exist
          for sig_file in $(ls ./*.asc); do
            runCommand rm -v "${sig_file}"
          done
          # sign the MariaDB source tarball
          runCommand gpg2 ${gpg_opts} mariadb*${galera_suffix}-${num}.tar.gz
          # sign the sum files as well
          runCommand gpg2 ${gpg_opts} md5sums.txt
          runCommand gpg2 ${gpg_opts} sha1sums.txt
          runCommand gpg2 ${gpg_opts} sha256sums.txt
          runCommand gpg2 ${gpg_opts} sha512sums.txt
          popd
          mv -vi /run/shm/${dir_name}/${dir_array[1]} ${dir_release}/${dir_name}/
          echo "+ copying ${dir_array[1]} to ${dir_corp}/${dir_name}/"
          runCommand rsync -avP --delete ${dir_release}/${dir_name}/${dir_array[1]} ${dir_corp}/${dir_name}/
        fi
        echo "+ transfer of ${dir_array[1]} done"
        echo
      elif runCommand rsync ${rsync_opts} "${location}/" "/run/shm/${dir_name}/${dir_array[1]}/"; then
        echo "+ transfer of ${dir_array[1]} done"
        pushd /run/shm/${dir_name}/${dir_array[1]}/
        if [ "${dir_array[1]}" = "bintar-linux-glibc_214-x86_64" ] || [ "${dir_array[1]}" = "bintar-linux-glibc_214-x86" ]; then
          # for the quantal bintars, we need to rename them before signing
          if [ "${dir_array[1]}" = "bintar-linux-glibc_214-x86_64" ]; then
            if [ -e *-linux-x86_64.tar.gz ] ; then
            runCommand mv -vi *-linux-x86_64.tar.gz ${version}-linux-glibc_214-x86_64.tar.gz
            fi
            galera_arch="x86_64"
          else
            if [ -e *-linux-i686.tar.gz ] ; then
            runCommand mv -vi *-linux-i686.tar.gz ${version}-linux-glibc_214-i686.tar.gz
            fi
            galera_arch="i686"
          fi

          if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
            # If this is a galera release we need to copy in the galera libraries
            # and repack the bintar
            runCommand tar -zxf ${version}-linux-glibc_214-${galera_arch}.tar.gz
            runCommand mv -vi ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}.tar.gz.orig
            if [ -d *-linux-${galera_arch} ]; then
            runCommand mv -vi *-linux-${galera_arch} ${version}-linux-glibc_214-${galera_arch}
            fi
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/bin/* ${version}-linux-glibc_214-${galera_arch}/bin/
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/lib/* ${version}-linux-glibc_214-${galera_arch}/lib/
            message "Copying over galera packages for ${dir_array[1]}"
            runCommand rsync --force -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/bin/ ${version}-linux-glibc_214-${galera_arch}/bin/
            runCommand rsync --force -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/lib/ ${version}-linux-glibc_214-${galera_arch}/lib/
            runCommand tar -czf ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}
            rm -rf ${version}-linux-glibc_214-${galera_arch}
          else
            echo "not a galera release, but still unpacking, re-packing so the dir name is correct"
            runCommand tar -zxf ${version}-linux-glibc_214-${galera_arch}.tar.gz
            runCommand mv -vi ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}.tar.gz.orig
            runCommand mv -vi *-linux-${galera_arch} ${version}-linux-glibc_214-${galera_arch}
            runCommand tar -czf ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}
            runCommand rm -rf ${version}-linux-glibc_214-${galera_arch}
          fi

          # since we renamed them, we also need to regenerate the sums
          if [ -e md5sums.txt ]; then
            runCommand rm -v md5sums.txt
          fi
          md5sum ./${version}-*.tar.gz >> md5sums.txt

          if [ -e sha1sums.txt ]; then
            runCommand rm -v sha1sums.txt
          fi
          sha1sum ./${version}-*.tar.gz >> sha1sums.txt

          if [ -e sha256sums.txt ]; then
            runCommand rm -v sha256sums.txt
          fi
          sha256sum ./${version}-*.tar.gz >> sha256sums.txt

          if [ -e sha512sums.txt ]; then
            runCommand rm -v sha512sums.txt
          fi
          sha512sum ./${version}-*.tar.gz >> sha512sums.txt

        elif [ "${dir_array[1]}" = "bintar-linux-systemd-x86_64" ] || [ "${dir_array[1]}" = "bintar-linux-systemd-x86" ]; then
          # for the systemd bintars, we need to rename them before signing
          if [ "${dir_array[1]}" = "bintar-linux-systemd-x86_64" ]; then
            if [ -e *-linux-x86_64.tar.gz ]; then
            runCommand mv -vi *-linux-x86_64.tar.gz ${version}-linux-systemd-x86_64.tar.gz
            fi
            galera_arch="x86_64"
          else
            if [ -e *-linux-i686.tar.gz ]; then
            runCommand mv -vi *-linux-i686.tar.gz ${version}-linux-systemd-i686.tar.gz
            fi
            galera_arch="i686"
          fi

          if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
            # If this is a galera release we need to copy in the galera libraries
            # and repack the bintar
            runCommand tar -zxf ${version}-linux-systemd-${galera_arch}.tar.gz
            runCommand mv -vi ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}.tar.gz.orig
            if [ -d *-linux-${galera_arch} ]; then
            runCommand mv -vi *-linux-${galera_arch} ${version}-linux-systemd-${galera_arch}
            fi
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/bin/* ${version}-linux-systemd-${galera_arch}/bin/
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/lib/* ${version}-linux-systemd-${galera_arch}/lib/
            message "Copying over galera packages for ${dir_array[1]}"
            runCommand rsync --force -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/bin/ ${version}-linux-systemd-${galera_arch}/bin/
            runCommand rsync --force -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/lib/ ${version}-linux-systemd-${galera_arch}/lib/
            runCommand tar -czf ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}
            runCommand rm -rf ${version}-linux-systemd-${galera_arch}
          else
            echo "not a galera release, but still unpacking, re-packing so the dir name is correct"
            runCommand tar -zxf ${version}-linux-systemd-${galera_arch}.tar.gz
            runCommand mv -vi ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}.tar.gz.orig
            runCommand mv -vi *-linux-${galera_arch} ${version}-linux-systemd-${galera_arch}
            runCommand tar -czf ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}
            runCommand rm -rf ${version}-linux-systemd-${galera_arch}
          fi

          # since we renamed them, we also need to regenerate the sums
          if [ -e md5sums.txt ]; then
            runCommand rm -v md5sums.txt
          fi
          md5sum ./${version}-*.tar.gz >> md5sums.txt

          if [ -e sha1sums.txt ]; then
            runCommand rm -v sha1sums.txt
          fi
          sha1sum ./${version}-*.tar.gz >> sha1sums.txt

          if [ -e sha256sums.txt ]; then
            runCommand rm -v sha256sums.txt
          fi
          sha256sum ./${version}-*.tar.gz >> sha256sums.txt

          if [ -e sha512sums.txt ]; then
            runCommand rm -v sha512sums.txt
          fi
          sha512sum ./${version}-*.tar.gz >> sha512sums.txt

        elif [ "${dir_array[1]}" = "bintar-linux-x86_64" ] || [ "${dir_array[1]}" = "bintar-linux-x86" ]; then
          if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
            # If this is a galera release we need to copy in the galera libraries
            # and repack the bintar, but first we need to set ${galera_arch} to the
            # correct value
            if [ "${dir_array[1]}" = "bintar-linux-x86_64" ]; then
              if [ "${is_ent}" = "yes" ];then
                runCommand mv -vi *-linux-x86_64.tar.gz ${version}-linux-x86_64.tar.gz
              fi
              galera_arch="x86_64"
            else
              if [ "${is_ent}" = "yes" ];then
                runCommand mv -vi *-linux-i686.tar.gz ${version}-linux-i686.tar.gz
              fi
              galera_arch="i686"
            fi
            runCommand tar -zxf ${version}-linux-${galera_arch}.tar.gz
            runCommand mv -vi ${version}-linux-${galera_arch}.tar.gz ${version}-linux-${galera_arch}.tar.gz.orig
            # if the directory isn't named like we want, rename it
            if [ ! -d ${version}-linux-${galera_arch} ]; then
              runCommand mv -vi *-linux-${galera_arch} ${version}-linux-${galera_arch}
            fi
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/bin/* ${version}-linux-${galera_arch}/bin/
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib*/* ${version}-linux-${galera_arch}/lib/
            message "Copying over galera packages for ${dir_array[1]}"
            runCommand rsync --force -av --exclude=*systemd ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/bin/ ${version}-linux-${galera_arch}/bin/
            runCommand rsync --force -av --exclude=*systemd ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib/ ${version}-linux-${galera_arch}/lib/
            #if [ -d ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib64 ];then
            #  rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib64 ${version}-linux-${galera_arch}/
            #fi
            runCommand tar -czf ${version}-linux-${galera_arch}.tar.gz ${version}-linux-${galera_arch}
            rm -rf ${version}-linux-${galera_arch}
            # since we repacked them, we also need to regenerate the sums
            if [ -e md5sums.txt ]; then
              runCommand rm -v md5sums.txt
            fi
            md5sum ./${version}-*.tar.gz >> md5sums.txt

            if [ -e sha1sums.txt ]; then
              rm -v sha1sums.txt
            fi
            sha1sum ./${version}-*.tar.gz >> sha1sums.txt

            if [ -e sha256sums.txt ]; then
              rm -v sha256sums.txt
            fi
            sha256sum ./${version}-*.tar.gz >> sha256sums.txt

            if [ -e sha512sums.txt ]; then
              rm -v sha512sums.txt
            fi
            sha512sum ./${version}-*.tar.gz >> sha512sums.txt

          else
            echo "not repacking as this is not a galera release"
          fi
        fi

        echo "+ generating sums in ${dir_array[1]} if they don't exist..."
        if [ -e md5sums.txt ]; then
          echo "...md5sums.txt exists"
        else
          echo "...generating md5sums.txt"
          md5sum ./${version}-* >> md5sums.txt
        fi

        if [ -e sha1sums.txt ]; then
          echo "...sha1sums.txt exists"
        else
          echo "...generating sha1sums.txt"
          sha1sum ./${version}-* >> sha1sums.txt
        fi

        if [ -e sha256sums.txt ]; then
          echo "...sha256sums.txt exists"
        else
          echo "...generating sha256sums.txt"
          sha256sum ./${version}-* >> sha256sums.txt
        fi

        if [ -e sha512sums.txt ]; then
          echo "...sha512sums.txt exists"
        else
          echo "...generating sha512sums.txt"
          sha512sum ./${version}-* >> sha512sums.txt
        fi

        echo "+ finished generating sums in ${dir_array[1]}"

        echo "+ signing files in ${dir_array[1]}..."
        # remove any signature files before signing, if they exist
        for sig_file in $(ls ./*.asc); do
          runCommand rm -v "${sig_file}"
        done
        # now that old signatures are gone, sign all files that remain
        for dir_file in $(find . -type f | grep -v orig); do
          runCommand gpg2 ${gpg_opts} ${dir_file}
        done
        popd
        mv -vi /run/shm/${dir_name}/${dir_array[1]} ${dir_release}/${dir_name}/
        echo "+ finished signing files in ${dir_array[1]}"
        echo
        echo
        # copy the dir to the corp dir
        echo "+ copying ${dir_array[1]} to ${dir_corp}/${dir_name}/"
        runCommand rsync -avP --delete ${dir_release}/${dir_name}/${dir_array[1]} ${dir_corp}/${dir_name}/
        echo
        echo
      else
        echo "! failed to transfer ${dir_array[1]}"
        # if the transfer failed, the directory might be empty, if it is we want it
        # removed, so we run rmdir on it
        #rmdir ${dir_release}/${dir_name}/${dir_array[1]}
        runCommand rmdir -v /run/shm/${dir_name}/${dir_array[1]}
        runCommand rmdir -v /run/shm/${dir_name}
        echo
      fi
    fi
  done

  # if we are creating a Galera release we need to copy in the galera source and
  # packages (for those not using the repositories)
  if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
    message "transferring Galera source and package files..."
    for galera_version in ${ver_galera_real}; do
      mkdir -vp ./galera-${galera_version}
      # rsync the galera dir to the release dir
      if runCommand rsync ${rsync_opts} --exclude=repo "${dir_galera}/galera-${galera_version}-${suffix}/" "./galera-${galera_version}/"; then
        # rsync the galera dir to the corp dir
        if runCommand rsync ${rsync_opts} --exclude=repo --exclude=*ppc64* --exclude=deb/ --exclude=rpm/ "${dir_galera}/galera-${galera_version}-${suffix}/" "${dir_corp}/${dir_name}/galera-${galera_version}/"; then
          echo "+ transfer of ${dir_galera}/galera-${galera_version} done"
        fi
        echo
      else
        echo "! failed to transfer ${dir_galera}/galera-${galera_version}"
        # if the transfer failed, the directory might be empty, if it is we want it
        # removed, so we run rmdir on it
        rmdir "galera-${galera_version}"
        echo
      fi
    done
    lowkey_message "done transferring Galera source and package files"
    echo
  fi

  message "done transfering bintar & source packages"
  echo
else
  echo
  line
  echo "+ skipping transfering bintar & source packages, as requested..."
  line
  echo
fi



#-------------------------------------------------------------------------------
#  Windows packages
#-------------------------------------------------------------------------------
# We don't need Windows packages for Galera, so don't even try
if [ "${galera_suffix}" != "-galera" ]; then
  if [ "${create_win}" != "no" ]; then
    maybe_create_release_dir
    #maybe_fix_permissions # fix permissions if they haven't already been fixed
    pushd ${dir_release}/${dir_name}
    line
    echo "+ transfering Windows packages..."
    line
    for arch in winx64; do
      if [ ! -d ${dir_release}/${dir_name}/${arch}-packages ]; then
        mkdir ${dir_release}/${dir_name}/${arch}-packages
      fi
      pushd ${dir_release}/${dir_name}/${arch}-packages


      if ${ci_release}; then
        message "Packages are on the local filesystem"
      else
      shouldI pull_the_win_packages_from_the_win_builder
      fi

      for pkgtype in msi zip; do
        #wget -N ${winbuilder}/${tree}/${rev}/${version}-${arch}.${pkgtype}
        if ${win_remote};then
          message "Packages are on the Windows Builder"
        runCommand wget -N ${winbuilder}/${tree}/build-${tarbuildnum}/${arch}-packages/${version}-${arch}.${pkgtype}
        elif ${ci_release}; then
          if [ "${pkgtype}" = "msi" ];then
          case ${arch} in
            winx64) windir=windows ;;
          esac
          runCommand rsync -avP ${dir_archive}/ci/${tree}/${tarbuildnum}/${windir}*/${version}-${arch}.${pkgtype} .
          fi
        else
          message "Packages are on the local filesystem"
          runCommand rsync -avP ${dir_archive}/${tree}/build-${tarbuildnum}/${arch}-packages/${version}-${arch}.${pkgtype} .
        fi

        if ! ${ci_release};then
        # Download debugsymbols package for 10.2+ releases
        if [ "${pkgtype}" = "zip" ]; then
          case ${tree} in
            '5.5'|'5.5-galera'|'10.0'|'10.0-galera'|'10.1'|'bb-10.1-release'|'bb-10.0-release')
              echo "+ tree=${tree}, so not downloading debugsymbols package..."
              ;;
            *)
              echo "+ tree=${tree}, so downloading debugsymbols package..."
              if ${win_remote};then
                # Win packages are on the remote builder
              runCommand wget -N ${winbuilder}/${tree}/build-${tarbuildnum}/${arch}-packages/${version}-${arch}-debugsymbols.${pkgtype}
              else
                # Win packages are on the local filesystem
                runCommand rsync -avP ${dir_archive}/${tree}/build-${tarbuildnum}/${arch}-packages/${version}-${arch}-debugsymbols.${pkgtype} .
              fi
              ;;
          esac
        fi
        fi

      done
      #wget ${winbuilder}/${tree}/${rev}/md5sums.txt
      if ! ${ci_release};then
      if ${win_remote} ; then
        # Win packages are on the remote builder
        if [ -e md5sums.txt ]; then # if md5sums.txt exists, delete it before downloading
          runCommand rm -v md5sums.txt*
        fi
      runCommand wget ${winbuilder}/${tree}/build-${tarbuildnum}/${arch}-packages/md5sums.txt
      else
        # Win packages are on the local filesystem
        runCommand rsync -avP ${dir_archive}/${tree}/build-${tarbuildnum}/${arch}-packages/md5sums.txt .
      fi
      fi
    done
    message "Generating Windows Checksums and Signatures..."
    for arch in winx64; do
      pushd ${dir_release}/${dir_name}/${arch}-packages
      pwd
      if ${ci_release};then
        md5sum ./mariadb* > md5sums.txt
      else
      runCommand dos2unix md5sums.txt
      grep ${arch} md5sums.txt > md5sums.txt.tmp
      mv -v md5sums.txt.tmp md5sums.txt
      #pwd
      #cat md5sums.txt
      #echo
      #echo
      #rm -v md5sums.txt
      #md5sum mariadb* >> md5sums.txt
      #cat md5sums.txt
      #echo
      md5sum -c md5sums.txt
      fi
      sha1sum ./mariadb* > sha1sums.txt
      sha1sum -c sha1sums.txt
      sha256sum ./mariadb* > sha256sums.txt
      sha256sum -c sha256sums.txt
      sha512sum ./mariadb* > sha512sums.txt
      sha512sum -c sha512sums.txt
      echo
      echo "+ signing ${arch} files"
      # remove any signature files before signing, if they exist
      for sig_file in $(ls ./*.asc); do
        rm "${sig_file}"
      done
      # now that old signatures are gone, sign all files that remain
      for dir_file in $(find . -type f); do
        gpg2 ${gpg_opts} ${dir_file}
      done
      echo "+ finished signing ${arch} files"
      echo
      echo

      # copy the dir to the corp dir
      echo "+ copying ${arch}-packages to ${dir_corp}/${dir_name}/"
      rsync -avP --delete ${dir_release}/${dir_name}/${arch}-packages ${dir_corp}/${dir_name}/
      popd
    done
    popd
    echo "+ done transfering Windows packages"
  else
    line
    echo "+ skipping transfering Windows packages, as requested..."
    line
  fi
fi


#-------------------------------------------------------------------------------
#  Repositories
#-------------------------------------------------------------------------------
if [ "${galera_suffix}" = "-galera" ]; then
  # We don't have separate .deb or .rpm package repos for Galera so if we're
  # doing a Galera release, don't try to create them in the normal way,
  # instead, run the galera-new script to add packages to existing repositories

  line
  echo "+ adding Galera Cluster files to existing repos..."
  line
  echo + ${GALERA_NEW} ${create_debian} ${create_ubuntu} ${create_yum} ${is_ent} ${tree} ${rev} ${num} ${tarbuildnum}
         ${GALERA_NEW} ${create_debian} ${create_ubuntu} ${create_yum} ${is_ent} ${tree} ${rev} ${num} ${tarbuildnum}

else
  maybe_create_release_dir
  pushd ${dir_release}/${dir_name}
  # Since this is not a galera release, create repos normally
  echo
  echo
  echo
  # if the dir doesn't exist, create it
  if [ ! -d ${dir_release}/${dir_name}/repo ]; then
    mkdir ${dir_release}/${dir_name}/repo
  fi

  if [ ! -d ${dir_corp}/${dir_name}/repo ]; then
    mkdir ${dir_corp}/${dir_name}/repo
  fi

  pushd ${dir_release}/${dir_name}/repo

  # create directory for the non-mgc version, if ubuntu or debian packages are
  # going to be created and if it doesn't already exist
  if [ "${create_debian}" != "no" ] || [ "${create_ubuntu}" != "no" ]; then
    if [ ! -d ${dir_release}/repo-no-mgc/${num} ]; then
      mkdir -vp ${dir_release}/repo-no-mgc/${num}
    fi
  fi

  if [ "${create_ubuntu}" != "no" ] || [ "${create_debian}" != "no" ] || [ "${create_yum}" != "no" ] || [ "${rsync_debian_repo}" != "no" ] || [ "${rsync_ubuntu_repo}" != "no" ]; then
    if [ ! ${prev_release} ] ; then
      set_prev_release
    fi
  fi

  #-------------------------------------------------------------------------------
  #  Create Debian Repos
  #-------------------------------------------------------------------------------
  if [ "${create_debian}" != "no" ]; then
    ## if the debian repo dir exists, delete it
    #if [ -d ${dir_release}/${dir_name}/repo/debian ]; then
    #  rm -rf "${dir_release}/${dir_name}/repo/debian"
    #fi

    # trying updating the previous repo instead of creating a new one every time
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/debian ${dir_release}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/debian ${dir_release}/${dir_name}/repo/
    echo

    line
    echo "+ creating Debian repos..."
    line
    if ${ci_release}; then
      runCommand ${DEBIAN} ${incl_galera} ${is_ent} ${tree} debian ${dir_archive}/ci/${tree}/${tarbuildnum}
    else
    echo "${DEBIAN} ${incl_galera} ${is_ent} ${tree} debian ${dir_archive}/${tree}/build-${tarbuildnum}"
     ${DEBIAN} ${incl_galera} ${is_ent} ${tree} debian ${dir_archive}/${tree}/build-${tarbuildnum}
    fi

    # copy the repo to the corp release dir
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/debian ${dir_corp}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/debian ${dir_corp}/${dir_name}/repo/
    echo
    # remove ppc64el from repo config and update repo
    sed -i s'/ppc64el //' ${dir_corp}/${dir_name}/repo/debian/conf/distributions
    pushd ${dir_corp}/${dir_name}/repo/debian/
      vi conf/distributions   # delete sid, if necessary
      reprepro -V --basedir . --delete clearvanished
      # remove the now missing entries from the sum files
      for sum in md5 sha1 sha256 sha512;do
        sed -i '/ppc64el/d' ${sum}sums.txt
      done
    popd

    echo
  elif [ "${rsync_debian_repo}" != "no" ]; then
    # This is a version of MariaDB that no longer gets updates for Debian
    # distros, but we want to maintain the last versions we released
    line
    echo "+ rsyncing old Debian repos..."
    line
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/debian ${dir_release}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/debian ${dir_release}/${dir_name}/repo/
    echo
  else
    line
    echo "+ Skipping Debian repo creation, as requested..."
    line
  fi

  #-------------------------------------------------------------------------------
  #  Create Ubuntu Repos
  #-------------------------------------------------------------------------------
  if [ "${create_ubuntu}" != "no" ]; then
    ## if the ubuntu repo dir exists, delete it
    #if [ -d ${dir_release}/${dir_name}/repo/ubuntu ]; then
    #  rm -rf "${dir_release}/${dir_name}/repo/ubuntu"
    #fi

    # trying updating the previous repo instead of creating a new one every time
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/ubuntu ${dir_release}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/ubuntu ${dir_release}/${dir_name}/repo/
    echo

    line
    echo "+ creating Ubuntu repos..."
    line

    # This is where the repository is actually updated
    if [ "${is_ent}" = "yes" ];then
      runCommand ${UBUNTU} ${incl_galera} ${is_ent} ubuntu ${dir_archive}/${tree}/build-${tarbuildnum} ${dir_archive_p8}/${tree}/${rev}
    else
      if ${ci_release}; then
        runCommand ${UBUNTU} ${incl_galera} ${is_ent} ubuntu ${dir_archive}/ci/${tree}/${tarbuildnum}
      else
        runCommand ${UBUNTU} ${incl_galera} ${is_ent} ubuntu ${dir_archive}/${tree}/build-${tarbuildnum} ${dir_archive_p8}/${tree}/${rev}
      fi
    fi

    # copy the repo to the corp release dir
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/ubuntu ${dir_corp}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/ubuntu ${dir_corp}/${dir_name}/repo/
    echo 
    # remove ppc64el from repo config and update repo
    sed -i s'/ppc64el //' ${dir_corp}/${dir_name}/repo/ubuntu/conf/distributions
    sed -i s'/s390x //' ${dir_corp}/${dir_name}/repo/ubuntu/conf/distributions
    pushd ${dir_corp}/${dir_name}/repo/ubuntu/
      vi conf/distributions # remove deprecated distros
      reprepro -V --basedir . --delete clearvanished
      # remove the now missing entries from the sum files
      for sum in md5 sha1 sha256 sha512;do
        sed -i '/ppc64el/d' ${sum}sums.txt
      done
    popd

    echo
  elif [ "${rsync_ubuntu_repo}" != "no" ]; then
    # This is a version of MariaDB that no longer gets updates for Ubuntu
    # distros, but we want to maintain the last versions we released
    line
    echo "+ rsyncing old Ubuntu repos..."
    line
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/ubuntu ${dir_release}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/ubuntu ${dir_release}/${dir_name}/repo/
    echo
  else
    line
    echo "+ Skipping Ubuntu repo creation, as requested..."
    line
  fi
  pushd ${dir_release}/${dir_name}
  echo

  #-------------------------------------------------------------------------------
  #  Create Yum Repos
  #-------------------------------------------------------------------------------
  if [ "${create_yum}" != "no" ]; then
    line
    echo "creating Yum repos..."
    line
    if [ -d ${dir_release}/${dir_name}/yum ]; then
      rm -rf "${dir_release}/${dir_name}/yum"
    fi

    # We can't create the yum dir on an nfs server, so we create it in our home
    # dir first
    mkdir -vp ${dir_yum_prep}/${dir_name}

    echo "Before rsyncing the yum release..."

    shouldI display_the_previous_yum_directory

    shouldI exclude_an_old_release_from_the_yum_dir

    # Rsync a copy of the previous release to ${HOME}
    if [ "${exclude_release}" = "" ]; then
      rsync_wrapper "-av --delete-before --exclude=*updateinfo.xml.gz ${dir_release}/mariadb-${prev_release}/yum ${dir_yum_prep}/${dir_name}/"
    else
      rsync_wrapper "-av --delete-before --exclude=*updateinfo.xml.gz --exclude=*${exclude_release}* ${dir_release}/mariadb-${prev_release}/yum ${dir_yum_prep}/${dir_name}/"
    fi
    #echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/yum ${HOME}/"
    #        rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/yum ${HOME}/
    echo

    pushd ${dir_yum_prep}/${dir_name}/yum
      # Run the yum script to create/update yum/dnf/zypp repos
      if ${ci_release}; then
        runCommand ${YUM} ${incl_galera} ${is_ent} ${dir_archive}/ci/${tree}/${tarbuildnum}
      else
      runCommand ${YUM} ${incl_galera} ${is_ent} ${dir_archive}/${tree}/build-${tarbuildnum} ${dir_archive_p8}/${tree}/${rev}
      fi
    popd

    # move the yum dir to where it needs to go
    echo "+ mv -i ${dir_yum_prep}/${dir_name}/yum ${dir_release}/${dir_name}/"
            mv -i ${dir_yum_prep}/${dir_name}/yum ${dir_release}/${dir_name}/
            rmdir -v ${dir_yum_prep}/${dir_name}
    pushd ${dir_release}/${dir_name}/

    # copy the yum dir to the corp release dir
    echo "+ copying the yum dir to the corp release dir"
    echo "+ rsync -a --info=progress2 --exclude=ppc64 --exclude=ppc64le --delete ${dir_release}/${dir_name}/yum ${dir_corp}/${dir_name}/"
            rsync -a --info=progress2 --exclude=ppc64 --exclude=ppc64le --delete ${dir_release}/${dir_name}/yum ${dir_corp}/${dir_name}/
    echo
    echo "+ remove ppc64 and ppc64le versions from corp release (if they were accidentally copied over)"
    pushd ${dir_corp}/${dir_name}/yum/
      rm -v *ppc64*
      rm -vrf */*/ppc64*
    popd

    # after creating the yum repo, copy it to ${dir_release}/yum-no-mgc (deleting
    # an old version beforehand, if one exists)
    if [ ! -d ${dir_release}/yum-no-mgc ]; then
      mkdir -vp ${dir_release}/yum-no-mgc
    fi
    if [ -d ${dir_release}/yum-no-mgc/${num} ]; then
      echo "+ rm -rf ${dir_release}/yum-no-mgc/${num}"
      rm -rf ${dir_release}/yum-no-mgc/${num}
    fi
    #echo "+ cp -ai ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}"
    #        cp -ai ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}
    case ${tree} in
      '5.5'|'10.0'|'bb-5.5-release'|'bb-10.0-release')
        echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}"
                rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}
        ;;
    esac
    echo
  else
    line
    echo "+ Skipping Yum repo creation, as requested..."
    line
  fi
fi

echo
echo
line
echo "+ done with repo creation for the ${version} release"
line
echo

shouldI create_package_tarballs

echo;echo;echo;echo

#bundles
#
#echo;echo;echo;echo

shouldI use_the_staging_mirror

if [ "${skip_staging}" = "no" ]; then
  shouldI upload_to_the_staging_mirror
  echo;echo;echo;echo
  shouldI copy_release_dir_to_corp_dir_so_corp_upload_is_smaller
  echo;echo;echo;echo
  shouldI upload_corp_dir_to_the_staging_mirror
  echo;echo;echo;echo
fi

echo;echo;echo;echo

shouldI copy_the_previous_release_to_the_current_release_on_the_mirrors

echo;echo;echo;echo

shouldI upload_to_the_corp_mirror_staging_dir

echo;echo;echo;echo

shouldI activate_the_corp_staging_repos

echo;echo;echo;echo

shouldI upload_to_the_primary_mirror

echo;echo;echo;echo

shouldI copy_the_corp_mirror_staging_dir_to_prod

echo;echo;echo;echo

shouldI upload_to_the_corp_mirror

echo;echo;echo;echo

shouldI upload_to_the_yum_mirrors

echo;echo;echo;echo

shouldI activate_the_yum_repos

echo;echo;echo;echo

shouldI activate_the_deb_repos

echo;echo;echo;echo

shouldI activate_the_corp_repos

echo;echo;echo;echo

case $tree in
  *5.5* )
    echo "+ no Docker for 5.5"
    ;;
  *)
    shouldI update_the_docker_library_mariadb_version
    ;;
esac

echo;echo;echo;echo

shouldI generate_the_file_list_pickle_for_org_downloads

echo;echo;echo;echo

#if [ "${skip_staging}" = "no" ]; then
  shouldI upload_this_release_to_the_buildmaster
  echo;echo;echo;echo
#fi
  shouldI update_the_STATUS_file

echo "+ all done!"
echo;echo;echo;echo

# vim: filetype=sh
